---
title="程序结构导论(2): 执行分析"
subtitle="结果怎么又双叒和我想的不一样?!"
description="程序的执行是机械性的, 数据和控制的流动是有规律可循的.
SSA形式则大力帮助了编译器/你的电脑, 对程序执行流程进行分析, 优化.
要像你的电脑一样, 机械地思考程序是怎么执行, 专治跳跃式思维."
avatar="/avatar/xhe.png"
last_modified="2020-11-01 20:14:23"
publish=true
author="xhe"
license="by-nc-sa"
---

程序执行只关心两点: 数据/变量怎样变动, 控制/步骤怎么进行.

数据流和控制流是两个适用于所有编程语言的抽象概念, 描述了程序怎样执行, 一般用图来展示, 是分析程序执行逻辑的工具.

之后再简单介绍内存管理.

## 数据流/控制流

下图以一个简单c语言程序展示:

```c
int a = 1;
if (a > 5)
	a = a + 1;
else
	a = a - 1;
```

![flow1](./flow_1.svg)

我们用红色箭头标识控制的传递, 黑色箭头表示数据的流动. 数据的流动是指各个常量, 变量从哪一个存储空间, 转移到了另一个存储空间; 而控制的传递是指, 什么时候应该根据什么条件执行什么操作, 执行完成后应该接着执行哪个控制逻辑.

注意, 执行流是从上到下的红色箭头, 数据流是从下到上的黑色箭头. 以上图为例, 程序首先从最顶部`a_0 = 1`开始, 对应源程序`a = 1`.

通过红色箭头, 传递控制到分支`a_0 > 5`, 对应源程序`if (a > 5)`. 需要a的数据和5的数据进行比较, 所以有从下倒上指向5黑色箭头, 指向`a_0 = 1`的双向红色箭头.

源程序中, 当`a > 5`时, 才会去执行`a = a + 1`, 反之执行`a = a - 1`. 对应到图中, `a_0 > 5`时, 从红色箭头指向`a_1 = a_0 + 1`这一支走, 否则从`a_2 = a_0 + 1`这一支走.

最后两个分支都通过红色箭头, 传递控制到`a_3 = phi(a_1, a_2)`. 这是属于SSA[^ssa]形式的`phi()`函数. 通俗的讲, 当程序的控制从`a_1 = a_0 + 1`传递到`a_3 = phi(a_1, a_2)`时, `a_3 = a_1`; 当程序的控制从`a_2 = a_0 - 1`传递到`a_3 = phi(a_1, a_2)`时, `a_3 = a_2`.

[^ssa]: [静态单一赋值](//zhuanlan.zhihu.com/p/57787118), [SSA - wikipedia](//en.wikipedia.org/wiki/Static_single_assignment_form), 两个参考

下面拆分本图, 分开介绍不同的组成元素.

### 赋值(assignment) & 表达式(expression)

```c
a = 3 + 4;
```

![flow2](./flow_2.svg)

将一个常量, 变量从一个地方, 转储到另一个地方. 用黑色箭头, 从起始指向目的.

![flow3](./flow_3.svg)

为简化作图, 突出重点, 表达式计算, 比如`3 + 4`这类四则运算, 可以合并到一个区块内. 同理, 其他区块, 也有类似简写标记, 逻辑清晰即可, 不作强制要求.

### 跳转(jump)

```c
a = 3;
a = a + 1;
```

![flow4](./flow_4.svg)

跳转, 是控制转移的另一种说法: 从一个控制逻辑, 跳转到另一个控制逻辑; 从一条指令, 跳转到下一条指令; 从这一行代码, 跳转到下一行代码. 当然跳转不只可以是从这一行到下一行, 还可以跳转七八行(c语言中的`goto`).

为统一, 全部使用红色箭头, 从当前指令, 指向下一条要执行指令.

### 分支(branch)

```c
switch (a) {
case 1:
	b = 1;
	break;
case 2:
	b = 2;
	break;
case 3:
	b = 3;
	break;
// more branches
}
```

![flow5](./flow_5.svg)

分支不外乎接受n个参数, 计算后跳转到m不同指令. 比如c语言中的`if (cond)`, 就是接受`cond`表达式, 或者`cond`变量, 进入本分支, 或另一个分支. 而上图给出了, c语言中switch分支例子.

### 代码块(block)

```c
a = 3;
if (a > 4) {
	b = 1;
	c = 2;
}
```

![flow6](./flow_6.svg)

我们也经常把相关的逻辑划分到一块, 对应到图中就是, 将相关部分用大方块括起来. 你可以上图的方块当成一个函数:

```c
void f(int a) {
	if (a > 4) {
		b = 1;
		c = 2;
	}
}
```

当然, b和c在这种情况下是全局变量. 我们说跳转到一个区块的时候, 其实是跳转区块第一行代码, 所以规定一个区块必须有一个起始点: `entry`. 见下一节循环的例子.

### 循环

```c
b = 3
while (a > 4)
	a--;
b = 4;
```

![flow7](./flow_7.svg)

用图例表示一个while循环, `b=3`是程序开始执行起点, `entry`是循环区块的起点. 只要`a > 4`, 此分支就跳转到`a--`, 否则跳转到`b=4`. 你可能注意到, 这张图中我并没有写类似`a_0`, `a_1`这样的变量名称, 这也是SSA[^ssa]形式的一部分. 但SSA难以快速理解, 所以只留一道hard的思考/练习题. 现实中SSA的图例可以参照libfirm[^libfirm].

[^libfirm]: [libfirm](//pp.ipd.kit.edu/firm/GraphSnippets.html)

### 练习

1 . (easy) 画出下列程序的框图:

```c
int a = 3;
int b = 5;
if (b < 6) {
	b = 4
	a = a + b
}
```

要求使用代码块框起`{}`包围的部分.

2 . (easy) 画出下列程序的框图:

```c
int b = 0;
for (int i=0;i<10;i++)
	b++;
```

3 . (easy) 编程中的函数是什么东西? 你能画出下列函数的框图吗?

```c
void f1(int a) {
	a = a + 1;
}

void f2(int a, int b) {
	a = a + b;
}

int f3(int a, int b) {
	return a + b;
}
```

4 . (easy) 你能把1, 2题中的c程序, 改写成python程序吗?

5 . (normal) 画出下列程序的框图:

```c
int b = 0;
for (int i=0;i<10;i++) {
	b++;
	if (b > 5)
		break;
}
```

6 . (normal) 能把3, 5题中的c程序, 改写成python程序吗?

7 . (normal) 下列程序运行结果是什么?

```c
include <stdint.h>
include <stdio.h>

int main() {
	uint16_t a = 0x0102;
	printf("%d", (uint8_t)a);
	return 0;
}
```

是0x0102, 0x02, 0x01, 还是0x0201? 为什么?

提示: 尝试结合数据和解释一节, uint16_t为16bits, uint8_t为8bits

8 . (normal) 什么是递归, 你能写出一个递归函数吗?

9 . (hard) 什么是SSA形式, 有什么用(简要理解概念即可)?

10 . (hard) 你能画出下面程序的SSA形式框图吗:

```c
a = 5
while (a > 0)
	a--;
a = 4;
```

## 内存管理

正在写...

