---
title="程序结构导论"
descs=[
	{label="description", value="how to program?"},
	{label="author", value="xhe"},
	{label="last_modified"},
]
license="by-nc-sa"
---

## 简介

这门课将会介绍各类程序结构和组成. 目的是理解程序执行逻辑, 增长视野, 主要使用python教授. 因此, 你应该多思考, 总结, 掌握方法, 举一反三, 这才是这门课预期的学习效果.

同时, 课程的推进决定于个人的练习/实验进度, 作业并非强制性的, 可根据自己的时间自由调节, 不过建议一周内完成一节内容.

## FAQ

说明一些常见问题:

1 . 画图工具?

本文中所有流图都是使用graphviz的dot语言写成的, 比如第一张框图的源码在[这里](//github.com/xhebox/ioclub/blob/master/src/pages/posts/class/flow_1.dot). 可以自行百度graphviz教程, 或使用其他流程图生成工具. 这里有一个在线查看graphviz代码对应的图片的网站: [webgraphviz](http://www.webgraphviz.com/). 还有很多其他在线查看graphviz代码图片的工具.

2 . c语言教学?

这门课不再教授c语言语法, 转而交给学生自学. c入门建议阅读[菜鸟教程](//www.runoob.com/). c语言额外推荐c和指针, c专家编程, c的陷阱和缺陷, krc等书.

编程离不开实践, 不管是python自己的REPL[^REPL], 还是本站浏览器提供的[pyterm](/pyterm)都是绝佳的实验场地. 务必多多实验. 环境搭建可参考[菜鸟教程](//www.runoob.com/python3/python3-install.html)

[^REPL]: REPL, 即Read Eval Print Loop, 读取-执行-打印循环. 一个可以和你实时交互的编程环境. [python3REPL - 菜鸟教程](//www.runoob.com/python3/python3-interpreter.html)

3 . 宣讲会上说过的在线运行python?

~~我确实有做, 但线上还有点问题, 一周内修复.~~ 已修复, 请点击导航栏的py3终端, 需要下载20M数据包, 请注意.

4 . 课程内容改变?

本页内容是在不断更新的, 具体的改变我会写在[变更日志](#变更日志)这一节.

5 . 我有问题...?

直接在IO CLUB内部群中询问, 或者发在本站[源码](//github.com/xhebox/ioclub)的issue上.

## 变更日志

1. 第一节润色完成, 新增变量小节
2. 第二节内容完成, 已添加
3. 更改练习难度为easy, normal, hard, 调整一二节练习
4. 第二节答案放出
5. 标注需要阅读的菜鸟教程章节
6. 考虑到新生基础过于薄弱, 对本文结构大改, 变更为第一节python语法, 第二节数据流/控制流/内存管理, 第三节递归/树.

## 第一节: 编程入门

提问, 你是怎么做心算的? 比如, 你有三个数字$1, 2, 4, \dots$, 求和. 首先你$1 + 2 = 3$, 接着你$3 + 4 = 7$, 以此类推. 仔细反省一下你的计算过程, 这整个过程中你做了三件事情:

1. 把两个数字加起来, 拿到一个结果
2. 把结果暂时记住, 比如$1 + 2 = 3$的$3$, 以便和后面数字相加
3. 循环往复的进行步骤1-2, 直到所有数字穷尽

你可以通过反省自己的思考过程找到更多类似的例子, 你的思考不外乎以下的步骤:

1. 把某些事物暂时记住
2. 通过某些事物进行一些推断和计算, 记住一些新事物
3. 循环往复的进行步骤1-2, 直到你满意为止

对应到程序里, **推断/计算/循环就是各种表达式/语句**, 而**暂时记住就对应着变量**. 所以程序总的来说, 就是通过变量存储各种**状态**, 并通过其他结构(如表达式/语句), 对变量进行操作, **改变状态**直到满意为止. 状态可以是整数, 字符串, 或者任何可能的数据.

算盘, 也可以算是一种"计算机". 算盘的珠子位置对应着现在计算好的数字, 也就是**状态**, 一个变量, 打算盘就是在加减这个变量, **改变状态**. 而打算盘的这个人就是"程序".

以上是对程序的一个比喻, 下面介绍具体的python语法. 如果遇到陌生的词, 不要紧, 在别的地方还会见到. 这一大节的内容就是需要来回的看, 因为很多东西都是相互关联的.

### 变量

`b = 3`这条语句声明了一个变量(variable), 名字叫做`b`, 存储着一个整数: $3$.

变量必须有个名字, 这个操作叫做**声明变量**. 下面的语句, 声明了一个变量`b`, 且用`=`运算符, 让变量存储一个整数$3$. `print(b)`会把`b`的值, 那个整数, 输出在屏幕上.

```python
b = 3
print(b) # py
```

不声明变量, 变量就没有名字, 那么你后续就无法指代它. 下面有一个变量$4$, 但他没有名字, 你后续无法对他进行操作, 改变他的值, 所以也叫做**常量(constant)**.

```python
print(4)
```

在声明变量时必须**定义/初始化**, 否则会报错:

```python
b # Error: name 'b' is not defined
```

所以python中, 声明变量和定义变量是一回事, 而且更习惯叫定义变量.

变量都是数据, 数据就有各式各类, 也就是有各种数据类型. 数据类型很复杂, 之后才详细介绍, 不要太纠结.

### 表达式

表达式(expression)是由变量和运算符(`+/-/*/%`之类的)组成的, 类似`(a+b) * 4`.

#### 运算符

运算符(operator)按作用数可以分为:

1. `a++`, `--a`, 一元运算符, 也就是只作用于一个变量, 可进一步根据运算符和变量之间的位置细分为前缀`++a`/后缀`a--`
2. `a + b`, 二元运算符, 作用于两个变量, 最常用的一些
3. `a ? b : c`, 三元运算符, 作用于三个变量

运算符按功能可以分为:

1. 算术运算符, 如`a + b`
2. 比较运算符, 如`a < b`
3. 赋值运算符, 如`a = 3`
4. 逻辑运算符, 如`a and 3`
5. 位运算符, 如`a & 3`
6. 其余运算符, 如`a is b`

具体可以参考[菜鸟教程 - python3运算符](//www.runoob.com/python3/python3-basic-operators.html).

#### 运算符优先级

表达式有**结合顺序**的问题: `i+++2` 到底是`(i++)+2`还是`i+(++2)`? 或者说它是从左往右结合, 还是从右往左结合? 先结合`++`运算符, 还是先结合`+`运算符?

这得具体语言具体分析, 各种语言的**运算符优先级(operator precendence)**[^coperator]可能不一样.

[^coperator]: [c运算符优先级](//en.cppreference.com/w/c/language/operator_precedence)

对于c来说, 这是`(i++)+2`. 结合顺序可以通过`()`来解决, 这也是推荐的方法: 干脆就不要写让人迷惑的表达式, 直接写`(i++) + 2`.

python的结合顺序和c类似.

#### 求值顺序

表达式也有**求值顺序(order of evaluation)**[^csequence]的问题:

[^csequence]: [c求值顺序规则](//en.cppreference.com/w/c/language/eval_order)

```c
i = 3;
i = i++ + 1;
```

最后i的值, 到底是`i++`之后的3, 还是多加1之后的4? 答案是**未定义**[^cundefined]. c语言通过**序列点(sequence point)**来规范求值顺序和结果. c++也继承了c的规范, 不过c++17标准之后大有改动, `i = i++ + 1`在c++17之后并不是未定义行为.

[^cundefined]: [c未定义行为](//en.cppreference.com/w/c/language/behavior)

python的表达式的求值顺序和结合顺序是一致的, 不存在这种c语言这种求值顺序, 结合顺序不同的情况.

#### 副作用

c语言典型的语句是`c = 3;`赋值语句. 但赋值在c语言中其实是一个表达式: `(c = 3) == 3`. `c = 3;`被判定成语句的原因是末尾的`;`. 很多语言, 表达式加一个终止符`;`, 或者换行后, 就变成了一条语句.

`(c = 3) == 3`这样的表达式, 目的是计算并返回一个值, 但是本例中, 它也完成了一个变量的赋值, 这次赋值是表达式的**副作用(side effect)**. 还有一类常见副作用是IO操作, `printf("xx")`有返回值, 但你甚至可能从来都没用过. 它的主要作用, 打印到屏幕上, 其实是它的副作用.

**但是, 副作用并非必要**. 副作用几乎可以说是 **命令式编程(imperative programming)** 的特产. 有很多不同的方法可以抽象计算外的其他操作: 虽然大家都用语句抽象, 但可以用不同的方式去抽象. 比如, Haskell这个 **函数式编程(functional programming)** 语言中的**Monad**[^monad]. 或者SQL这种典型的 **声明式编程(declarative programming)** .

[^monad]: [haskell IO](//www.jianshu.com/p/7f715d4695ee)

### 语句

python是一门基于**缩进(indention)**的编程语言: python没有花括号, 不需要写分号. 作为替代, python需要保持正确的缩进, 来保证程序可以正常被解析. 你马上会见到例子.

#### 条件控制

```python
a = 1
if a == 2:
	print('a')
	print('c')

print('b')
```

以上代码输出`b`, 以下代码也输出`b`:

```python
a = 1
if a == 1:
	print('b')
else
	print('a')
```

`if`是条件判断语句, 后面跟着的是表达式, 如果表达式求值为**真(true)**, 就执行下面的代码. 这里下面的代码指的是, `if a == 1:`这一行下面比本行多一个tab或几个空格的行(直到不满足条件为止).

如果条件为**假(false)**, 就执行`else`下面的代码(如第二个例子), 或者接着执行后面的代码(如第一个例子). 但是条件判断可以级联:

```python
a = 1
if a == 2:
	print('c')
elif a == 3:
	print('b')
else
	print('a')
```

以上代码输出`a`, 首先判断`a == 2`得到假, 随后执行`a == 3`又得到假, 所以只好执行`else`下面的代码.

具体可以参考[菜鸟教程 - python3控制](//www.runoob.com/python3/python3-conditional-statements.html).

#### 循环

以下代码输出4个a.

```python
a = 3
while a >= 0:
	print('a')
	a -= 1
```

while循环的执行, 直到条件为假才结束, 但可以提前使用break结束. 下面代码只输出2个a:

```python
a = 3
while a >= 0:
	print('a')
	a -= 1
	if a == 2:
		break
```

还可以使用continue跳过执行, 下面代码什么都不输出:

```python
a = 3
while a >= 0:
	a -= 1
	continue
	print('a')
```

还有另一for循环, 也可以使用break和continue, 以下代码输出3个a:

```python
for a in range(3):
	print('a')
```

和别的语言不太一样的是, 循环语句后面可以跟`else`, 下面代码输出3个a, 1个b:

```python
for a in range(3):
	print('a')
else:
	print('b')
```

具体可以参考[菜鸟教程 - python3循环](//www.runoob.com/python3/python3-loop.html).

#### 函数

函数和变量一样都有一个名字, 只不过函数存储的是代码本身: 它就像数学的函数一样接受输入, 处理后返回输出, 而处理的代码是由你来定义的. 下面定义了一个叫做`sum`的函数, 接受两个叫做`a`, `b`的变量, 或者说**参数(argument)**, 返回两个参数的和:

```python
def sum(a, b):
	return a + b

sum(3, 4) # 7
```

`def sum(a, b):`下面的是函数体, 需要比`def`多缩进一个tab, 或几个空格. 而形如`sum(3, 4)`这样的语句被叫做函数调用, 通过名字执行预先定义好的过程, 进行代码的重复利用.

`return`是一个关键字, 标志着函数执行到这里就结束了, 下面的函数中`a = 3`不会被执行:

```python
def sum(a, b):
	return a + b
	a = 3 # not executed
```

当然, 函数也可以没有返回值.

具体可以参考[菜鸟教程 - python3函数](//www.runoob.com/python3/python3-function.html).

### 数据类型

给出数据34, 求它对应的十进制数字. 答案可以是34, 但也可以是52, 还可以是28. 这三个答案分别对应34是十进制, 十六进制, 八进制时, 对应的十进制大小. 因此一个数据可以有不同解释, 如果附加条件不同的话.

在编程语言中也有类似情况, 根据**类型(type)**不同, 数据可以有两种解释. 你对不同类型的变量, 能进行的操作也是不同的.

#### 类型声明

编程语言按是否需要显式声明变量的类型分为强类型, 弱类型两种编程语言.

下面是c语言中的变量定义, 每个变量都有具体的类型, 比如c的类型是`int`, `string`的类型是`char*`, 所以是强类型语言.

```c
int c = 1;
char string[] = "hello";
```

强类型语言不存储变量信息, 即c语言并不关心底层存储的是什么数据. 恰恰相反, c语言会根据你给予的类型进行解释. 举个例子:

```c
int c = 1;
char *string = (char*)(&c);
```

通过强制类型转换整数为字符串, `string`这个字符串变量指向了变量c, 也就是指向了1. 但是打印[`printf("%s", string)`]结果并不是1, 因为`string`是个字符串变量. 所以它会把1对应的二进制数据`0x00000001`解释为一个字符串. 按字符串解释方法, 每两个十六进制数, 即每byte对应一个字符, `0x00`是字符串的终止符, `0x01`是不可打印的控制字符. 所以不管怎么样, 结果中都不可能出现1.

下面是py语言中的变量定义, 除了名字初始值什么都没有, 所以是弱类型语言. 弱类型语言并非没有类型, 而是把类型信息通过某种方式隐藏, 你看不到, 也不需要看到. 程序自动检查类型信息, 遇到数字就输出数字, 遇到字符串就输出字符串. 一般来说, 类型信息是紧跟这变量存储的.

```py
c = 1
string = 'hello'
```

这两类语言共同点是, 不管是哪种语言, 都是通过类型信息来解释底层的二进制数据, 进行不同的操作. 区别只在于需不需要声明变量类型; 运行时还是编译时推断类型; 类型信息是怎么存储的.

#### 数字

python中的数字分三种: 整数(int), 浮点数(float), 复数(complex).

整数可以用八进制(octal), 十进制(decimal), 十六进制(hexadecimal)表示:

```python
37 # decimal
0o37 # octal
0x37 # hex
```

由于计算机内存有限, 一个变量能表示的数字有上下限, 只能表示区间$[a, b]$之内的数.

浮点数, 即实数, 遵循IEEE 754实现, 同样由于现实原因, 浮点数有上下限, 且计算时容易丢失精度, 造成结果不正确:

```python
3.2
.3
3e2
3e-2
```

复数由两个浮点数组成, 通过`complex`函数构建, 可以通过`.real/.imag`获取实部/虚部:

```python
c = complex(1, 2) # 1.0 + 2.0j
c.real # 1.0
c.imag # 2.0
```

复数例子中, $1$和$2$都是整数, 但被**隐式(implicit)**转换为浮点数, 或者说自动转换. 你也可以**显式(explicit)**, 或者说手动转换:

```python
a = int(1.0) # 1
b = float(1) # 1.0
```

具体可以参考[菜鸟教程 - python3数字](//www.runoob.com/python3/python3-number.html).

#### 字符串

python没有char类型, 所有字符相关的都是字符串, 既可以使用单引号, 可以用双引号:

```python
"hello"
'hello'
```

因为**解析(parse)**代码时, 技术上的一些原因, 在定义字符串时, 其中某些字符需要**转移(escape)**, 比如双引号需要写成`\"`:

```python
"f\"ee\"" # 'f"ee"'
```

字符串, 顾名思义, 是一串字符, 所以自然可以通过数字可以获取其中某个, 或某些字符:

```python
a = "hello"
a[0] # 'e'
a[3] # 'l'
a[1:3] # 'el'
a[:4] # 'hell'
a[3:] # 'lo'
a[-3:] # 'llo'
```

字符串虽然不是数字, 但作为变量, 也可以对它使用运算符, `a[3]`, `a[3:]`本质上是一元运算符. 二元的有`+`拼接运算符:

```python
a = 'h' + 'e'
print(a) # 'he'
```

比较特别的是`%`这个二元运算符, 它可以用来做**格式化(formatting)**:

```python
print("%d + %d = %d" % (1, 2, 3)) # 1 + 2 = 3
```

其中`"%d + %d = %d"`是格式化字符串, `%d`叫做**格式符(format specifier)**. 右侧是一个元组, 其中每一个变量都对应一个格式符. 最终输出的字符串中, 每个格式符都会被替换成, 元组中对应的变量的字符串形式.

具体可以参考[菜鸟教程 - python3字符串](//www.runoob.com/python3/python3-string.html)

#### 列表

**列表(list)**是一串有序的变量, 可以插入新的变量, 删除旧的变量, 改变现有变量:

```python
a = [1, 2, 'str']
del a[0] # delete 1 from the list a
a # [2, 'str']
```

和字符串一样可以使用`[]`和`[:]`运算符:

```python
a = [1, 2, 'str']
a[0] # 1
a[1:] # [2, 'str']
a[-3:] # [1, 2, 'str']
```

列表其实是一个**对象(object)**, 他有很多**方法(methods)**用来做很多事情, 这是面向对象编程的概念. 比如列表的方法`count`, 会返回列表中变量的个数:

```python
a = [1, 2, 2, 'str']
a.count(2) # 2
```

简单来说, 方法可以理解为一个函数, 但是自动的多接受一个输入, 也就是对象这个变量本身作为输入. 举个例子, 如果先忽略怎么实现`count`方法的问题, 上面的可以重写为:

```python
def count_us(list, elem):
	# count code here

a.count(2) == count_us(a, 2) # True
```

具体可以参考[菜鸟教程 - python3列表](//www.runoob.com/python3/python3-list.html)

#### 元组

**元组(tuple)**是一串有序的变量, 和列表类似. 但是元组本身不允许被修改, 一经定义, 存储的变量就已经固定, 但是变量本身可以被修改:

```python
a = (1, 2, 'str')
a = 1, 2, 3
>>> del a[0]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object doesn't support item deletion
```

和字符串一样可以使用`[]`和`[:]`运算符:

```python
a = (1, 2, 'str')
a[0] # 1
a[1:] # [2, 'str']
a[-3:] # [1, 2, 'str']
```

元组也是一个对象, 也有很多方法.

具体可以参考[菜鸟教程 - python3元组](//www.runoob.com/python3/python3-tuple.html)

#### 集合

**集合(set)**和数学里的类似, 无序, 不重复:

```python
{1, 2}
set((1, 2))
set() # empty set
```

注意, 空集合定义不能使用`{}`, 因为这定义了一个字典. 集合是一个对象, 有很多方法.

具体可以参考[菜鸟教程 - python3集合](//www.runoob.com/python3/python3-set.html)

#### 字典

**字典(dictionary)**可以看成是存储了一堆元组的集合, 判断重不重复以元组的第一个变量为依据:

```python
{} # empty dict
{'first': 1, 'second': 2}
{'first': 1, 'second': 2, 'first': 3} # {'first': 1, 'second': 2}
```

只可以使用`[]`运算符:

```python
a = {'first': 1, 'second': 2}
a['first'] # 1
a['second'] # 2
```

字典是一个对象, 有很多方法.

具体可以参考[菜鸟教程 - python3字典](//www.runoob.com/python3/python3-dictionary.html)

### python vs 其他语言

下面列举一些python和其余语言的差别.

c语言可以只声明变量, 却不定义, 下面声明了变量a存在, 但没有指定它最开始的值是什么.

```c
int a;
```

javascript语言非严格模式下, 不需要提前声明变量, 未声明的变量有一个默认值`undefined`:

```js
console.log(a) // output: undefined
```

## 第二节: 执行分析

程序执行只关心两点: 数据/变量怎样变动, 控制/步骤怎么进行.

数据流和控制流是两个适用于所有编程语言的抽象概念, 描述了程序怎样执行, 一般用图来展示, 是分析程序执行逻辑的工具.

之后再简单介绍内存管理.

### 数据流/控制流

下图以一个简单c语言程序展示:

```c
int a = 1;
if (a > 5)
	a = a + 1;
else
	a = a - 1;
```

![flow1](./class/flow_1.svg)

我们用红色箭头标识控制的传递, 黑色箭头表示数据的流动. 数据的流动是指各个常量, 变量从哪一个存储空间, 转移到了另一个存储空间; 而控制的传递是指, 什么时候应该根据什么条件执行什么操作, 执行完成后应该接着执行哪个控制逻辑.

注意, 执行流是从上到下的红色箭头, 数据流是从下到上的黑色箭头. 以上图为例, 程序首先从最顶部`a_0 = 1`开始, 对应源程序`a = 1`.

通过红色箭头, 传递控制到分支`a_0 > 5`, 对应源程序`if (a > 5)`. 需要a的数据和5的数据进行比较, 所以有从下倒上指向5黑色箭头, 指向`a_0 = 1`的双向红色箭头.

源程序中, 当`a > 5`时, 才会去执行`a = a + 1`, 反之执行`a = a - 1`. 对应到图中, `a_0 > 5`时, 从红色箭头指向`a_1 = a_0 + 1`这一支走, 否则从`a_2 = a_0 + 1`这一支走.

最后两个分支都通过红色箭头, 传递控制到`a_3 = phi(a_1, a_2)`. 这是属于SSA[^ssa]形式的`phi()`函数. 通俗的讲, 当程序的控制从`a_1 = a_0 + 1`传递到`a_3 = phi(a_1, a_2)`时, `a_3 = a_1`; 当程序的控制从`a_2 = a_0 - 1`传递到`a_3 = phi(a_1, a_2)`时, `a_3 = a_2`.

[^ssa]: [静态单一赋值](//zhuanlan.zhihu.com/p/57787118), [SSA - wikipedia](//en.wikipedia.org/wiki/Static_single_assignment_form), 两个参考

下面拆分本图, 分开介绍不同的组成元素.

#### 赋值(assignment) & 表达式(expression)

```c
a = 3 + 4;
```

![flow2](./class/flow_2.svg)

将一个常量, 变量从一个地方, 转储到另一个地方. 用黑色箭头, 从起始指向目的.

![flow3](./class/flow_3.svg)

为简化作图, 突出重点, 表达式计算, 比如`3 + 4`这类四则运算, 可以合并到一个区块内. 同理, 其他区块, 也有类似简写标记, 逻辑清晰即可, 不作强制要求.

#### 跳转(jump)

```c
a = 3;
a = a + 1;
```

![flow4](./class/flow_4.svg)

跳转, 是控制转移的另一种说法: 从一个控制逻辑, 跳转到另一个控制逻辑; 从一条指令, 跳转到下一条指令; 从这一行代码, 跳转到下一行代码. 当然跳转不只可以是从这一行到下一行, 还可以跳转七八行(c语言中的`goto`).

为统一, 全部使用红色箭头, 从当前指令, 指向下一条要执行指令.

#### 分支(branch)

```c
switch (a) {
case 1:
	b = 1;
	break;
case 2:
	b = 2;
	break;
case 3:
	b = 3;
	break;
// more branches
}
```

![flow5](./class/flow_5.svg)

分支不外乎接受n个参数, 计算后跳转到m不同指令. 比如c语言中的`if (cond)`, 就是接受`cond`表达式, 或者`cond`变量, 进入本分支, 或另一个分支. 而上图给出了, c语言中switch分支例子.

#### 代码块(block)

```c
a = 3;
if (a > 4) {
	b = 1;
	c = 2;
}
```

![flow6](./class/flow_6.svg)

我们也经常把相关的逻辑划分到一块, 对应到图中就是, 将相关部分用大方块括起来. 你可以上图的方块当成一个函数:

```c
void f(int a) {
	if (a > 4) {
		b = 1;
		c = 2;
	}
}
```

当然, b和c在这种情况下是全局变量. 我们说跳转到一个区块的时候, 其实是跳转区块第一行代码, 所以规定一个区块必须有一个起始点: `entry`. 见下一节循环的例子.

#### 循环

```c
b = 3
while (a > 4)
	a--;
b = 4;
```

![flow7](./class/flow_7.svg)

用图例表示一个while循环, `b=3`是程序开始执行起点, `entry`是循环区块的起点. 只要`a > 4`, 此分支就跳转到`a--`, 否则跳转到`b=4`. 你可能注意到, 这张图中我并没有写类似`a_0`, `a_1`这样的变量名称, 这也是SSA[^ssa]形式的一部分. 但SSA难以快速理解, 所以只留一道hard的思考/练习题. 现实中SSA的图例可以参照libfirm[^libfirm].

[^libfirm]: [libfirm](//pp.ipd.kit.edu/firm/GraphSnippets.html)

#### 练习

1 . (easy) 画出下列程序的框图:

```c
int a = 3;
int b = 5;
if (b < 6) {
	b = 4
	a = a + b
}
```

要求使用代码块框起`{}`包围的部分.

2 . (easy) 画出下列程序的框图:

```c
int b = 0;
for (int i=0;i<10;i++)
	b++;
```

3 . (easy) 编程中的函数是什么东西? 你能画出下列函数的框图吗?

```c
void f1(int a) {
	a = a + 1;
}

void f2(int a, int b) {
	a = a + b;
}

int f3(int a, int b) {
	return a + b;
}
```

4 . (easy) 你能把1, 2题中的c程序, 改写成python程序吗?

5 . (normal) 画出下列程序的框图:

```c
int b = 0;
for (int i=0;i<10;i++) {
	b++;
	if (b > 5)
		break;
}
```

6 . (normal) 能把3, 5题中的c程序, 改写成python程序吗?

7 . (normal) 下列程序运行结果是什么?

```c
#include <stdint.h>
#include <stdio.h>

int main() {
	uint16_t a = 0x0102;
	printf("%d", (uint8_t)a);
	return 0;
}
```

是0x0102, 0x02, 0x01, 还是0x0201? 为什么?

提示: 尝试结合数据和解释一节, uint16_t为16bits, uint8_t为8bits

8 . (normal) 什么是递归, 你能写出一个递归函数吗?

9 . (hard) 什么是SSA形式, 有什么用(简要理解概念即可)?

10 . (hard) 你能画出下面程序的SSA形式框图吗:

```c
a = 5
while (a > 0)
	a--;
a = 4;
```

### 内存管理

正在写...

## 第三节: 递归和树

### 递归

函数是接受输入, 给定输出的一个过程:

```py
def add(x, y):
	return x + y
```

最初的目的是提取经常重复写的代码, 为它起个名字, 这样不用一遍一遍写. 第一节控制流小节说的代码块可以看成函数, 就是这个意思. 如果你把一个代码块提出来, 起个名字, 那其实就和函数一样了. 函数后来进一步拓展出**作用域**, **形参/实参**, **递归**等衍生话题.

大多语言只允许返回一个返回值, 有些语言(go语言)允许返回多个返回值. 到这里, 函数已经完全不像原本的数学中的函数的定义了, 务必不要拿数学的函数来理解程序的函数.

这一节主要讲递归:

```py
def sum(x):
	if x == 1:
		return 1
	return sum(x - 1) + x
```

你不要知道栈, 就能理解递归. 假设函数:

$$
sum(x) = \sum _ {i=1}^x i
$$

可得

$$
sum(x) = \sum _ {i=1}^{x-1} i + x
= sum(x-1) + x \quad x > 1
$$

这是对应的数学表示, 第二个递推式只在$x > 1$时成立. 现在来看看它对应的程序框图:

![flow8](./class/flow_8.svg)

这个框图$x \neq 1$的时候, 完美的反应了递推式. 递推式只有在$x > 1$时成立, 因此, 我们在x减少到$x = 1$时, 不再使用递推关系, 而是直接返回$1$. 因为$sum(1) = 1$.

可以说递归的核心就是:

1. 大问题化小问题
2. 通过递归调用解决小问题
3. 额外几步计算, 通过小问题的答案给出大问题的答案

而递推就是一个典型的可以这么做的情况. 动态规划这类算法问题就常写出递推公式, 所以动态规划的问题可以用递归解决.

至于为什么可以这样写, 递归的时候数据是怎么流动的, 之后几节再说. 现在来看看斐波那契的例子:

```py
def fib(x):
	if x == 1 or x == 2:
		return 1
	return fib(x-1) + fib(x-2)
```

对应的递推公式:

$$
f(1) = 1
\\
f(2) = 1
\\
f(x) = f(x-1) + f(x-2) \quad x > 2
$$

有n级楼梯, 可以1次跨一级台阶, 或1次二级台阶, 有多少种爬法? 对应的递推公式:

$$
f(1) = 1
\\
f(2) = 1 + 1 = 2
\\
f(n) = f(n-1) + f(n-2)
$$

你可以看到这个公式就是fibnacci.

这个问题可以到着来思考, 假设你已经站在第n级. 爬楼梯要么一级, 要么两级, 所以要么是从n-1级迈一步到n级, 要么是直接从n-2跨两级到n级.

所以从n-1到n只有一种爬法, n-2级到n级只有一种爬法. 假设你已经知道, n-1级的爬法次数, 还有n-2级的爬法次数, 相加即得到n级的爬法次数.

你可能会说n-2到n级, 还可以迈两次两个一级, 那种情况迈一级之后就变成n-1到n级的情况, 已经重叠了, 所以不需要重复考虑.

#### 练习

1 . (easy) 本节中的爬楼梯, 写出代码, 画出程序框图

有n级楼梯, 可以1次跨一级台阶, 或1次二级台阶, 有多少种爬法?

**答案**:

此处有[leetcode 原题](//leetcode-cn.com/problems/climbing-stairs/)

c写法:

```c
int f(int n) {
	if (n == 1 || n == 2) return n;
	return f(n-1) + f(n-2);
}

printf("res = %d\n", f(3));
// res = 3
```

py写法:

```python
def f(n):
	if n == 1 or n == 2:
		return n
	return f(n-1) + f(n-2)

print("res = ", f(3));
# res = 3
```

框图:

![sec2_1](./class/sec2_1.svg)

2 . (easy) 阶乘$f(x) = x!$, 写出代码

递推式:

$$
f(1) = 1
\\
f(x) = f(x-1) * x \quad x > 1
$$

c写法:

```c
int f(int n) {
	if (n == 1) return n;
	return f(n-1) * n;
}

printf("res = %d\n", f(3));
// res = 6
```

py写法:

```python
def f(n):
	if n == 1:
		return 1
	return f(n-1) * n

print("res = ", f(3))
# res = 6
```

3 . (easy) 有n级楼梯, 可以1次跨一级,二级,三级台阶, 有多少种爬法? 求代码

递推式:

$$
f(1) = 1
\\
f(2) = 2
\\
f(3) = 4
\\
f(x) = f(x-1) + f(x-2) + f(x-3) \quad x > 3
$$

跨一级只有一种走法, 跨两级有$1+1$和$2$两种走法. 跨三级: $1+1+1$, $1+2$, $2+1$, $3$.

c写法:

```c
int f(int n) {
	if (n == 1) return 1;
	if (n == 2) return 2;
	if (n == 3) return 4;
	return f(n-1) + f(n-2) + f(n-3);
}

printf("res = %d\n", f(4));
// res = 7
```

py写法:

```python
def f(n):
	if n == 1:
		return 1
	if n == 2:
		return 2
	if n == 3:
		return 4
	return f(n-1) + f(n-2) + f(n-3)

print("res = ", f(4))
# res = 7
```

4 . (easy) 有n级楼梯, 可以1次跨一级,三级台阶, 有多少种爬法? 写出代码

递推式:

$$
f(1) = 1
\\
f(2) = 1
\\
f(3) = 2
\\
f(x) = f(x-1) + f(x-3) \quad x > 3
$$

跨一级只有一种走法, 跨两级: $1+1$, 跨三级: $1+1+1$, $3$.

c写法:

```c
int f(int n) {
	if (n == 1 || n == 2) return 1;
	if (n == 3) return 2;
	return f(n-1) + f(n-3);
}

printf("res = %d\n", f(4));
// res = 3
```

py写法:

```python
def f(n):
	if n == 1 or n == 2:
		return 1
	if n == 3:
		return 2
	return f(n-1) + f(n-3)

print("res = ", f(4))
# res = 3
```

5 . (normal) 求杨辉三角, 第m行, 第n个数字(m/n从0开始)? 写出代码

递推式, 杨辉三角的某个数等于上一行左右两个数之和:

$$
f(m, n) = 1 \text{ if } n = 0
\\
f(m, n) = 1 \text{ if } m = n
\\
f(m, n) = f(m-1, n-1) + f(m-1, n) \text{ if }  n > 0 \cap m > 0
$$

c写法:

```c
int f(int m, int n) {
	if (n == 0 || m == n) return 1;
	return f(m-1, n-1) + f(m-1, n);
}

printf("res = %d\n", f(4, 3)); // 第五行第四个
// res = 4
```

py写法:

```c
def f(m, n):
	if n == 0 or m == n:
		return 1
	return f(m-1, n-1) + f(m-1, n)

print("res = ", f(4, 3))
" res = 4
```

6 . (normal) 从n个球中取出m个$C_n^m$，一共有多少可能性? 写出代码

递推式:

$$
C_n^m = 1 \text { if } n = m
\\
C_n^m = \frac{n!}{m!(n-m)!}
\\
= \frac{(n-1)!}{m!(n-1-m)!} \times \frac{n}{n-m}
\\
= C _ {n-1}^m \times \frac{n}{n-m} \text{ if } n-1 \geq m
$$

c写法:

```c
int f(int n, int m) {
	if (n == m) return 1;
	return f(n-1, m) * n / (n-m);
}

printf("res = %d\n", f(4, 3));
// res = 4
```

py写法:

```python
def f(n, m):
	if n == m:
		return 1
	return f(n-1, m) * n / (n-m)

print("res = ", f(4, 3))
" res = 4.0
```

7 . (normal) 汉诺塔最少移动次数, 写出代码

三个柱子：A, B, C. A柱子上有n个环，将n个环全部移动到C上最少移动次数. (大环不能放在小环上, A柱子上的环符合本要求)

**答案**:

一个环可直接移动.

两个环需要先将小的从A移动到B上, 大的从A移动到C上, 最后小的从B到C, 一共3次.

考虑有3个环, 我们需要先将前两个从A移动到B, 第三个从A移动到C上, 最后前两个从B到C, 一共$3 + 1 + 3 = 7$次. 这其中, 前两个从A移动到B, 从B移动到C的过程, 和两个环A移动到C的步骤是高度相似的.

考虑n个环, 将前n-1个从A移动到B, 第n个从A移动到C, 最后前n-1个B移动到C. 如果忽略第n个环, 你可以认识到将n-1个环从A移动到B, 从B移动到C的过程是一样的, 只是起始柱子, 目的柱子, 用来临时放环的空闲柱子不同而已.

因此, 可以得出递推式:

$$
f(1) = 1
\\
f(n) = f(n-1) * 2 + 1 \text{ if } n > 1
$$

为什么是最少呢? 因为若想将第n个环挪到C上, 第n个环上必然没有其他环, 且C上也没有其他环(第n个环是最大的). 所以要想实现这个过程, 必定需要将前n-1个环挪动到B上, 才能开始挪动第n个环, 而挪动第n个环后, 也只剩挪动前n-1个环到C上一种操作. 因此, 操作方法是唯一的(排除你一直小环来回挪不做正事的可能性), 所以也一定是最少的.

c写法:

```c
int f(int n) {
	if (n == 1) return 1;
	return f(n-1) * 2 + 1;
}

printf("res = %d\n", f(4));
// res = 15
```

py写法:

```python
def f(n):
	if n == 1:
		return 1
	return f(n-1) * 2 + 1

print("res = ", f(4))
" res = 15
```

8 . (hard) 爬楼梯的递归代码中存在重复计算吗? 可以在仍然使用递归的方法下避免重复计算吗? 若可以, 给出代码

存在, 可以避免.

c写法:

```c
int computed[1024] = {1, 2, 0};

int f(int n) {
	if (computed[n] != 0) return computed[n];
	int r = f(n-1) + f(n-2);
	computed[n] = r;
	return r;
}

printf("res = %d\n", f(3));
// res = 3
```

9 . (hard) 下面的c语言代码是不是未定义行为? 为什么

```c
int a[3] = {1, 2, 3};
int i = 1;
a[i++] = i;
```

**答案**:

是. 根据c语言标准, `a[i++] = i;`只有两个序列点, 赋值`=`和`;`. 赋值后直接通过`;`结束语句, 这两个序列点之间没有其他操作, 所以不存在问题(`a=3,c=4;`这样写就有其他操作了).

在向数组赋值前, 需要计算`i++`和`i`的值, 但因为赋值前没有其他序列点, 所以`i++`和`i`的求值顺序不确定先后, 而且本行为未定义.

这行代码可能执行为`a[2] = 1`, 也可能是`a[1] = 2`, 或者直接让你的电脑死机, 这都是执行预期内的行为.

10 . (hard) 补完下列c程序:

```c
int sum(int a) {
	// 写出代码
}
```

函数接受参数a, 返回结果$sum(a) = \sum_{i=1}^a i$, 只许使用递归, 变量, `&&`, `||`, `==`, `=`, `+`, `-`.

提示: 试画出`&&`和`||`的程序框图.

**答案**:

```c
int sum(int a) {
	int r = 1;
	a == 1 || (r = sum(a-1) + a);
	return r;
}
```

### 树

正在写...
